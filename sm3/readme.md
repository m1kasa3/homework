## 循环左移优化说明

### 原始版本的问题：

```cpp
uint32_t RL(uint32_t a, uint8_t k) {
    k = k % 32;  // 使用模运算
    return ((a << k) & 0xFFFFFFFF) | ((a & 0xFFFFFFFF) >> (32 - k));
}
```

### 优化后的版本：

```cpp
static inline uint32_t RL(uint32_t a, uint8_t k) {
    k &= 31;  // 使用位运算代替模运算
    return (a << k) | (a >> (32 - k));  // 简化位运算
}
```

## 优化点详解

### 1. 模运算优化

原版：`k = k % 32` - 需要除法运算

优化：`k &= 31` - 使用位运算，更快

原理：`31 = 0b11111`，`& 31` 等价于 `% 32`

### 2. 位运算简化

原版：`((a << k) & 0xFFFFFFFF) | ((a & 0xFFFFFFFF) >> (32 - k))`

优化：`(a << k) | (a >> (32 - k))`

原理：在32位系统中，左移和右移会自动处理溢出

### 3. 内联函数

添加：`static inline` 关键字

效果：减少函数调用开销，编译器可能内联展开


