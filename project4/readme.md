# 优化
## 循环左移优化说明

### 原始版本的问题：

```cpp
uint32_t RL(uint32_t a, uint8_t k) {
    k = k % 32;  // 使用模运算
    return ((a << k) & 0xFFFFFFFF) | ((a & 0xFFFFFFFF) >> (32 - k));
}
```

### 优化后的版本：

```cpp
static inline uint32_t RL(uint32_t a, uint8_t k) {
    k &= 31;  // 使用位运算代替模运算
    return (a << k) | (a >> (32 - k));  // 简化位运算
}
```

## 优化点详解

### 1. 模运算优化

原版：`k = k % 32` - 需要除法运算

优化：`k &= 31` - 使用位运算，更快

原理：`31 = 0b11111`，`& 31` 等价于 `% 32`

### 2. 位运算简化

原版：`((a << k) & 0xFFFFFFFF) | ((a & 0xFFFFFFFF) >> (32 - k))`

优化：`(a << k) | (a >> (32 - k))`

原理：在32位系统中，左移和右移会自动处理溢出

### 3. 内联函数

添加：`static inline` 关键字

效果：减少函数调用开销，编译器可能内联展开



---

# length extension attack
## 一、什么是length extension attack（长度扩展攻击）？

这是针对**Merkle-Damgård结构**（如MD5、SHA1、SM3等）的哈希算法的攻击。假设知道`hash(key || message)`，但不知道`key`，你可以**伪造**`hash(key || message || padding || new_data)`，而不需要知道`key`。这在“消息认证码（MAC）= hash(key || message)”的场景下，攻击者可以扩展消息并伪造合法MAC。

---

## 二、如何用SM3代码验证？

### 步骤思路

1. **已知：**
   - 原始消息`m`
   - 原始消息的哈希`h = SM3(key || m)`（假设key长度已知，但key内容未知）

2. **攻击者想要：**
   - 构造`m' = m || padding || new_data`
   - 计算`SM3(key || m || padding || new_data)`，得到新的合法哈希

3. **做法：**
   - 用`h`作为SM3的初始向量（IV），用SM3处理`new_data`，并设置正确的总长度（key长度 + m长度 + padding + new_data长度）

---

## 三、代码实现

### 1. 需要补充的函数

- **消息填充函数**（生成和SM3内部一样的padding）
- **允许自定义IV和消息总长度的SM3压缩函数**（用来模拟攻击）


    
## 四、总结

只要知道hash(key||m)和key长度，就能伪造hash(key||m||padding||new_data)。这说明**不能直接用SM3(key||msg)做MAC**，要用HMAC等安全方案。
# merkle tree
## 实现方案
哈希函数封装: 通过 OpenSSL 的 EVP 高级接口封装 SM3 哈希算法，提供一个独立的 sm3_hash 函数，方便调用。

遵循 RFC6962:

叶子节点哈希: 对 0x00 字节和原始叶子数据拼接后的内容进行 SM3 哈希。

内部节点哈希: 对 0x01 字节、左子节点哈希、右子节点哈希拼接后的内容进行 SM3 哈希。

奇数节点处理: 当某一层节点数量为奇数时，将最后一个节点复制一份与其自身配对，确保每一层都能完整地两两结合。

存在性证明 (Inclusion Proof):

生成: 找到目标叶子节点，自底向上遍历树的层级。在每一层，记录其兄弟节点的哈希值，形成一条“审计路径”(Audit Path)。

验证: 利用待验证的叶子数据和审计路径，从叶子哈希开始，逐层与路径中的兄弟哈希结合，重新计算根哈希。若计算结果与已知的 Merkle Root 一致，则证明通过。

非存在性证明 (Non-existence Proof):

方案: 由于 RFC6962 描述的是无序追加日志，无法直接进行高效的非存在性证明。本实验采用预先对叶子节点进行字典序排序的方案。

生成: 在排序树中，通过查找证明目标数据 D 的“插入点”，为该插入点的相邻叶子节点（例如，第一个大于 D 的叶子）生成一个标准的存在性证明。

验证: 首先验证相邻叶子的存在性证明是否有效。然后，通过比较字符串，验证目标数据 D 与该相邻叶子的大小关系是否符合预期（例如 D 确实小于该相邻叶子），从而间接证明 D 不在集合中。
## 结果与验证
树构建: 成功为 10 万个叶子节点构建了 Merkle 树，并生成了唯一的 32 字节 SM3 Merkle Root 哈希。

存在性证明验证:

成功场景: 随机选取叶子 leaf-data-54321，成功生成其存在性证明。使用该证明进行验证，计算出的根哈希与树的根哈希完全一致，验证成功。

失败场景: 使用相同的证明路径，但将叶子数据篡改为 leaf-data-tampered，验证失败。结果符合预期。

非存在性证明验证:

成功场景: 在排序树中，针对一个不存在的叶子 leaf-data-999999，成功生成了其非存在性证明。验证过程确认了其相邻叶子的存在性，并确认了 leaf-data-999999 在排序中的位置是无效的，验证成功。

失败场景: 尝试为一个已存在的叶子 leaf-data-100 生成非存在性证明，程序按预期逻辑返回失败（无法生成证明），结果符合预期。
